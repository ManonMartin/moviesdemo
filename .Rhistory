# Chunk 12
save(formula, outcomes, design, file=file.path(out_path, "data_matrixDecomposition.RData"))
# Décomposition de Y en matrice des effets par GLM
resGLM <- matrixDecomposition(formula, outcomes, design)
# construction de la liste des matrices des effets purs
EffectMatGLM=list(
Yalpha=resGLM$effectMatrices$Hip_prop,
Ybeta=resGLM$effectMatrices$Ci_prop,
Yalphabeta=resGLM$effectMatrices$`Hip_prop:Ci_prop`,
Yres=resGLM$residuals)
# construction de la liste des matrices des effets augmentés
EffectMatGLMAug=list(
Yalpha=resGLM$effectMatrices$Hip_prop+resGLM$residuals,
Ybeta=resGLM$effectMatrices$Ci_prop+resGLM$residuals,
Yalphabeta=resGLM$effectMatrices$`Hip_prop:Ci_prop`+resGLM$residuals,
Yres=resGLM$residuals)
# Chunk 13
pander(resGLM$modelMatrix)
pander(resGLM$residuals[,1:3] )
pander(resGLM$predictedValues[,1:3])
pander(resGLM$parameters[,1:3])
# Chunk 14
pander(resGLM$effectMatrices$Intercept[,1:3])
pander(resGLM$effectMatrices$Hip_prop[,1:3])
pander(resGLM$effectMatrices$Ci_prop[,1:3])
pander(resGLM$effectMatrices$`Hip_prop:Ci_prop`[,1:3])
# Chunk 15
VariationPercentages = matrix(nrow=p,ncol=1)
rownames(VariationPercentages) = ModelTerms
VariationPercentages[1,] = resGLM$variationPercentages$Hip_prop
VariationPercentages[2,] = resGLM$variationPercentages$Ci_prop
VariationPercentages[3,] = resGLM$variationPercentages$`Hip_prop:Ci_prop`
VariationPercentages[4,] = resGLM$variationPercentages$residuals
pander(VariationPercentages)
barplot(t(VariationPercentages))
# Chunk 17
Type3PC = matrix(nrow=p-1,ncol=1)
rownames(Type3PC) = ModelTerms[1:(p-1)]
Type3PC[1,] = norm(resGLM$Type3Residuals$Hip_prop, "F")^2
Type3PC[2,] = norm(resGLM$Type3Residuals$Ci_prop, "F")^2
Type3PC[3,] = norm(resGLM$Type3Residuals$`Hip_prop:Ci_prop`, "F")^2
pander(Type3PC)
barplot(t(Type3PC))
# Chunk 19
# Citrate scores and loadings
ascaSVD = SVDforPCA(EffectMatGLM[["Ybeta"]])
ascaSVD$scores = round(ascaSVD$scores,5)
ASCAScoresCitrate <- DrawScores(ascaSVD, type.obj = "PCA", drawNames = F,
createWindow = F,
main = "ASCA scores plot - Citrate effect",
axes = c(1, 2),
size=2.5, pch= Citrate, noLegend = TRUE)
ASCALoadingCitrate <- DrawLoadings(ascaSVD, type.obj = "PCA",createWindow = F, main = "ASCA loading plot - Citrate effect", axes = c(1), loadingstype = "s", num.stacked = 2, xlab = "ppm", ylab = "", ang = "0", xaxis = "numerical", nxaxis = 10)
# Chunk 21
# Citrate scores
ascaSVD = SVDforPCA(EffectMatGLM$Ybeta)
ascaSVD$scores[,1:2]=(EffectMatGLM$Ybeta+EffectMatGLM[["Yres"]])%*%ascaSVD$loadings[,1:2]
col <- c("0"="black", "QC/2" = "red")
ASCAEScoresCitrate <- DrawScores(ascaSVD, type.obj = "PCA", drawNames = F,
createWindow = F,
main = "ASCA-E scores plot - Citrate effect",
axes = c(1, 2),
size=2.5,  noLegend = TRUE,
pch = Citrate, color = Citrate) +
scale_colour_manual(name='Citrate:', breaks = c("0", "QC/2"),
values = c("black", "red")) +
scale_shape_manual(name='Citrate:', breaks = c("0", "QC/2"),
values = c(17, 16))
# Chunk 22
# Hippurate
ascaSVD = SVDforPCA(EffectMatGLM$Yalpha)
YHippurate_Loadings <- ascaSVD$loadings
ascaSVD$scores[,1:2]=(EffectMatGLM$Yalpha+EffectMatGLM[["Yres"]])%*%ascaSVD$loadings[,1:2]
ascaSVD_hip <- ascaSVD$scores[,1]
# Citrate
ascaSVD = SVDforPCA(EffectMatGLM$Ybeta)
YCitrate_Loadings <- ascaSVD$loadings
ascaSVD$scores[,1:2] = (EffectMatGLM$Ybeta+EffectMatGLM[["Yres"]])%*%ascaSVD$loadings[,1:2]
ascaSVD_cit <- ascaSVD$scores[,1]
#Hyp*Cit
ascaSVD = SVDforPCA(EffectMatGLM$Yalphabeta)
Yalphabeta_Loadings <- ascaSVD$loadings
ascaSVD$scores[,1:2] = (EffectMatGLM$Yalphabeta+EffectMatGLM[["Yres"]])%*%ascaSVD$loadings[,1:2]
ascaSVD_hipcit <- ascaSVD$scores[,1]
#Error
ascaSVD = SVDforPCA(EffectMatGLM$Yres)
ascaSVD$scores=round(ascaSVD$scores,5)
ascaSVD_error <- ascaSVD
ascaSVD_res1 <- ascaSVD_error$scores[,1]
ascaSVD_res2 <- ascaSVD_error$scores[,2]
# loadings plot
####################
loadingsAPCAGLM <- cbind(YHippurate_Loadings[,1],
YCitrate_Loadings[,1], Yalphabeta_Loadings[,1])
colnames(loadingsAPCAGLM) <- c("Hippurate PC1 loading",
"Citrate PC1 loading", "Cit*Hip PC1 loading")
# pdf(file.path(out_path, "ASCAELoadings.pdf"),
# width = 7.2, height=4.5)
LinePlot(t(loadingsAPCAGLM),  main = "ASCA-E-GLM Loadings", type = "s", num.stacked = 3, xlab = NULL, ylab = "", ang = "0", xaxis = "numerical", nxaxis = 10, y_axis_text = FALSE)
# dev.off()
# scores plot
####################
pcexp_pereffect_perPC <- VariationPercentages[1:3,]
pcexp_pereffect_perPC <- c(pcexp_pereffect_perPC, c(ascaSVD_error$var[1:2]/100)* VariationPercentages["Error",])
mat_ascaSVD <- cbind('Hippurate PC1' = ascaSVD_hip, 'Citrate PC1' = ascaSVD_cit, 'Hip*Cit PC1' = ascaSVD_hipcit, 'Residuals PC1' = ascaSVD_res1, 'Residuals PC2' = ascaSVD_res2)
labels <- paste0(colnames(mat_ascaSVD), "\n ",round(pcexp_pereffect_perPC,2), "%")
textlabel <- matrix("", ncol = dim(mat_ascaSVD)[2], nrow = dim(mat_ascaSVD)[1], dimnames = list(rownames(mat_ascaSVD), NULL))
textlabel[rownames(mat_ascaSVD) %in% c("M1C04D2R1", "M1C04D2R2", "M1C20D3R1"),] <- rep(c("a", "b", "c"), 5)
pch2 <- rep("", dim(mat_ascaSVD)[1])
pch2[rownames(mat_ascaSVD) %in% c("M1C04D2R1", "M1C04D2R2", "M1C20D3R1")] <- "O"
# pdf(file.path(out_path, "ASCAEScores.pdf"),
#     width = 7, height=5)
par(xpd = TRUE)
pairsBG(mat_ascaSVD,titre="ASCA-E Scores plots",
oma=c(3,3,5,15), labels = labels, spotPoints=TRUE)
legendsScatterMatrix()
# dev.off()
# Chunk 24
# Citrate scores and loadings
ascaSVD = SVDforPCA(EffectMatGLMAug$Ybeta)
ascaSVD$scores=round(ascaSVD$scores,5)
col <- c("0"="black", "QC/2" = "red")
APCAScoresCitrate <- DrawScores(ascaSVD, type.obj = "PCA",
drawNames = F, createWindow = F,
main = "APCA scores plot - Citrate effect",
axes = c(1, 2),
size=2.5, pch = Citrate, color = Citrate) +
scale_colour_manual(name='Citrate:', breaks = c("0", "QC/2"),
values = c("black", "red")) +
scale_shape_manual(name='Citrate:', breaks = c("0", "QC/2"),
values = c(17, 16)) +
guides(colour = guide_legend(override.aes = list(shape = c(17, 16), color = c("black", "red"))))
APCALoadingCitrate <- DrawLoadings(ascaSVD, type.obj = "PCA",createWindow = F, main = "APCA loading plot - Citrate effect", axes = c(1), loadingstype = "s", num.stacked = 2, xlab = "ppm", ylab = "", ang = "0", xaxis = "numerical", nxaxis = 10)
lay <- rbind(c(1,1,1,2,2,2,3,3,3,4),
c(5,5,5,5,5,6,6,6,6,6))
dev.new()
pdf(file.path(out_path, "ASCA_scoresloadings_Citrate.pdf"),
width = 12, height=6)
gridExtra::grid.arrange(ASCAScoresCitrate,
ASCAEScoresCitrate,
APCAScoresCitrate+
theme(legend.position = "none"),
get_legend(APCAScoresCitrate),
ASCALoadingCitrate[[1]] +
ylim(-0.2, 0.5),
APCALoadingCitrate[[1]]+
ylim(-0.2, 0.5),
layout_matrix=lay)
dev.off()
dev.off()
gridExtra::grid.arrange(ASCAScoresCitrate,
ASCAEScoresCitrate,
APCAScoresCitrate+
theme(legend.position = "none"),
get_legend(APCAScoresCitrate),
ASCALoadingCitrate[[1]] +
ylim(-0.2, 0.5),
APCALoadingCitrate[[1]]+
ylim(-0.2, 0.5),
layout_matrix=lay)
#KOPLS library
#install.package(kopls)
library(kopls)
library(plyr)
library(matrixcalc)
Yall =EffectMatGLM
ortho = 1
#Data preparation
Xres<-Yall[[length(Yall)]]
Y<-Yall[1:(length(Yall)-1)]
#Identify the number of matrices
f<-length(Y)
#Identify the number of observations
n<-nrow(Y[[1]])
#Create the response matrix
#Apply SVD to each submatrix and extract all non-zero eigenvectors = extract level barycentres
#Multiply U by the eigenvalues
#Then concatenate in responsematrix
#dec=number of decimals to round and decide if 0
responsematrix<-matrix(NA,nrow=n)
responsematrix<-matrix(NA,nrow=n)
Ysvd<-lapply(Y,svd)
for (i in 1:f){
for(j in 1:n){
if(round(Ysvd[[i]]$d[j],4)!=0){
responsematrix<-cbind(responsematrix,Ysvd[[i]]$u[,j]*Ysvd[[i]]$d[j])
}
}
}
responsematrix<-responsematrix[,-1]
#Same response matrix as in MatLab (aside from the sign of the last vector)
#
###Create the predictor kernel matrix
#Add the pure effects and residual submatrices = predictors Xi
predictors<-mapply(function(a) a+Xres, a = Y, SIMPLIFY = FALSE)
#Append the residual matrix to the list
predictors<-c(predictors,list(Xres))
xnorm<-numeric(0)
AMat<-list()
W_mat<-matrix(0,n,n)
#Loop for f matrices
#Loop doesn't work for 1:f+1, had to use 0
for (i in 0:f+1) {
#Create the kernel matrix with the augmented matrix as first matrix and no second matrix
#p=polynomial kernel, 1=parameter of the kernel function
temp<-koplsKernel(predictors[[i]],NA,'p',1)
#Calculate the spectral norm of the matrix and normalise
#xnorm[i]<-norm(temp,type="2")
xnorm[i]<-spectral.norm(temp)
AMat[[i]]<-temp/xnorm[i]
#Add all kernel matrices = predictor matrix W_mat
W_mat=W_mat+AMat[[i]]
}
## Model
#Number of predictive components = length of Y
#Number of Y-orthogonal components = ortho
finalmodel<-koplsModel(W_mat,responsematrix,ncol(responsematrix),ortho)
summary(finalmodel)
finalmodel
#Compute lambda
lambda<-matrix(NA,nrow=length(Yall),ncol=ncol(responsematrix)+ortho)
k=1
j=1
finalmodel$T[,k]
plot(finalmodel$T[,k])
lambda<-matrix(NA,nrow=length(Yall),ncol=ncol(responsematrix)+ortho)
for (j in 1:length(Yall)){
for (k in 1:ncol(responsematrix)){
lambda[j,k]<-finalmodel$T[,k]%*%AMat[[j]]%*%finalmodel$T[,k]
}
for (l in 1:ortho){
lambda[j,k+l]<-finalmodel$To[,l]%*%AMat[[j]]%*%finalmodel$To[,l]
}
}
lambda
points(finalmodel$To[,1])
points(finalmodel$To[,1], pch=2)
finalmodel$To[,1]
l=1
finalmodel$To[,l]%*%AMat[[j]]%*%finalmodel$To[,l]
finalmodel$To[,2]
finalmodel$To[,1]
AMat[[j]]
plot(AMat[[j]])
View(AMat[[j]])
finalmodel$To
devtools.desc.author
devtools.desc.author()
getOption(devtools.desc.author)
getOption("devtools.desc.author")
getOption("devtools.name")
getOption("devtools.desc")
Option("devtools.desc" = list(LazyData=TRUE))
options("devtools.desc" = list(LazyData=TRUE))
getOption("devtools.desc")
stop("suggestedPackage installation is necessary for function FUN",
call. = FALSE)
stop("suggestedPackage installation is necessary for function FUN",
call. = TRUE)
library("devtools", lib.loc="~/Library/R/3.4/library")
build()
library(moviesdemo)
library(moviesdemo)
library(moviesdemo)
library(moviesdemo)
library(moviesdemo)
build(manual=TRUE)
check(manual=TRUE)
shinyApp()
library("moviesdemo", lib.loc="~/Library/R/3.4/library")
runMovieApp()
help(moviesdemo)
library(moviesdemo)
library(moviesdemo)
?moviesdemo
??moviesdemo
?moviesdemo
help(moviesdemo)
help(moviesdemo)
devtools::load_all(".")
library("tidyr", lib.loc="~/Library/R/3.4/library")
library("knitr", lib.loc="~/Library/R/3.4/library")
install.packages("formatR")
tidy_app()
help("moviesdemo")
16624*1.05
install.packages("lintr")
lintr::lint_package()
FUN <- function(a , b = c("val1", "val2")){
b <- match.arg(b)
cat(a," :",  b, "\n")
}
FUN(b="val1")
FUN(b="val3")
mtcars
levels(c(1,2,3))
levels(c("1","2","3"))
FUN <- function(a, b){
levels(a)
}
FUN()
FUN(a = c(rep(1:3, 5)))
FUN <- function(a, b = c("levels", "nlevels")){
if(b=="levels") {
levels(a)
}else {nlevels(a)}
}
FUN
FUN()
FUN <- function(a, b = c("levels", "nlevels")){
b <- b[1]
if(b=="levels") {
levels(a)
}else {nlevels(a)}
}
FUN()
FUN(a=rep(1:3, 5))
FUN(a=rep(1:3, 5), b = "lebels")
FUN(a=as.factor(rep(1:3, 5)), b = "lebels")
FUN <- function(a, b = c("levels", "nlevels")){
b <- match.arg(b)
if(b=="levels") {
levels(a)
}else {nlevels(a)}
}
FUN(a=as.factor(rep(1:3, 5)), b = "lebels")
FUN(a=as.factor(rep(1:3, 5)), b = "levels")
FUN <- function(a, b = c("levels", "nlevels")){
b <- match.arg(b)
if (!is.factor(a)) {
stop(deparse(a), "is not a factor")
}
if(b=="levels") {
levels(a)
}else {nlevels(a)}
}
FUN(a=rep(1:3, 5), b = "lebels")
FUN(a=rep(1:3, 5), b = "levels")
e <- quote(`foo bar`)
deparse(e)
FUN(a=rep(1:3, 5), b = "levels")
FUN <- function(a, b = c("levels", "nlevels")){
b <- match.arg(b)
if (!is.factor(a)) {
stop(deparse(substitute(a)), "is not a factor")
}
if(b=="levels") {
levels(a)
}else {nlevels(a)}
}
FUN(a=rep(1:3, 5), b = "levels")
FUN <- function(a, b = c("levels", "nlevels")){
b <- match.arg(b)
if (!is.factor(a)) {
stop(deparse(substitute(a)), " is not a factor")
}
if(b=="levels") {
levels(a)
} else {nlevels(a)}
}
val <- rep(1:3, 5)
FUN(a = val, b = "lebels")
FUN(a = as.factor(val), b = "levels")
FUN <- function(a, b = c("levels", "nlevels")){
b <- b[1]
if(b=="levels") {
levels(a)
}else {nlevels(a)}
}
FUN(a=rep(1:3, 5), b = "lebels")
FUN(a=as.factor(rep(1:3, 5)), b = "lebels")
FUN <- function(a, b = c("levels", "nlevels")){
b <- match.arg(b)
if (!is.factor(a)) {
warning(deparse(substitute(a)), " is not a factor")
}
if(b=="levels") {
levels(a)
} else {nlevels(a)}
}
center <- function(a, type = c("mean", "median")) {
type <- match.arg(type)
if (!is.numeric(a)) {
warning(deparse(substitute(a)), " is not numeric")
}
switch(type,
mean = mean(a),
median = median(a))
}
center(a=c(1,2,3), type="meen")
center <- function(a, type = c("mean", "median")) {
# type <- match.arg(type)
if (!is.numeric(a)) {
warning(deparse(substitute(a)), " is not numeric")
}
switch(type,
mean = mean(a),
median = median(a))
}
center(a=c(1,2,3), type="meen")
val <- c(1,4,6, "b", 5, 2, 1)
FUN <- function(a, type = c("mean", "median")) {
switch(type,
mean = mean(a),
median = median(a))
}
val <- c(1, 4, 6, "R", 5, 2, 1)
FUN(a = val, type="meen")
FUN(a = val, type="mean")
val <- c(1, 4, 6, "R", 5, 2, 1)
FUN(a = val, type="mean")
val <- c(1, 4, 6, 5, 5, 2, 1)
FUN(a = val, type="meen")
require(knitr)
FUN <- function(a, type = c("mean", "median")) {
if (!is.numeric(a)) {
warning(deparse(substitute(a)), " is not numeric")
}
type <- match.arg(type)
switch(type,
mean = mean(a),
median = median(a))
}
FUN(a = c(1, 4, 6, "R", 5, 2, 1), type="meen")
FUN <- function(a, type = c("mean", "median")) {
switch(type,
mean = mean(a),
median = median(a))
}
FUN(a = c(1, 4, 6, "R", 5, 2, 1) , type="mean")
FUN <- function(a, type = c("mean", "median")) {
switch(type,
mean = mean(a),
median = median(a))
}
FUN(a = c(1, 4, 6, F, 5, 2, 1) , type="mean")
library("devtools", lib.loc="~/Library/R/3.4/library")
build(manual = TRUE)
build(manual = TRUE, path = "/Users/manon/Documents/SMCS")
system("R CMD Rd2pdf moviesdemo")
library(moviesdemo)
system("R CMD Rd2pdf moviesdemo")
system("R CMD Rd2pdf <moviesdemo>")
system("R CMD Rd2pdf ")
system("R CMD Rd2pdf .")
system("R CMD Rd2pdf .")
require(devtools)
document()
document()
document()
library("moviesdemo", lib.loc="~/Library/R/3.4/library")
require(devtools)
document()
library("moviesdemo", lib.loc="~/Library/R/3.4/library")
document()
document()
document()
library(moviesdemo)
document()
help(moviesdemo)
library("moviesdemo", lib.loc="~/Library/R/3.4/library")
help(moviesdemo)
library(moviesdemo)
help(moviesdemo)
movies
View(movies)
advise.good.movie("Tangled", 3)
scores = c(17.24038 ,17.07466 ,16.71365)
names =  c("Frozen"  ,        "Big Hero 6"    ,  "Winnie the Pooh")
to_watch=names
names(scores) <- to_watch
scores
barplot(scores)
barplot(scores, ylim=c(0,ceiling(scores)))
ceiling(scores)
barplot(scores, ylim=c(0,ceiling(max(scores))))
m <- barplot(scores, ylim=c(0,ceiling(max(scores))))
m
text(m,scores, labels = scores)
text(m,scores*0.9, labels = scores)
text(m,scores*1.9, labels = scores)
text(m,scores*1.1, labels = scores)
m <- barplot(scores, ylim=c(0,ceiling(max(scores))), col = "blue")
text(m,scores*0.9, labels = scores)
text(m,scores*0.9, labels = scores, col="white")
text(m,scores*0.9, labels = round(scores,2), col="white")
m <- barplot(scores, ylim=c(0,ceiling(max(scores))), col = "blue", main = "Movie scores")
text(m,scores*0.9, labels = round(scores,2), col="white")
nn
document()
document()
library(moviesdemo)
devtools::use_build_ignore("notes")
devtools::use_build_ignore("/Users/manon/Documents/SMCS/Formations/RPackages/Content/moviesdemo/.travis.yml")
library("lintr", lib.loc="~/Library/R/3.4/library")
on.exit()
Rcpp::cppFunction(depends = "RcppArmadillo", 'arma::cx_mat mExp_C(arma::cx_mat A) {
arma::cx_mat A_exp = arma::expmat(A);
return A_exp;
}')
Rcpp::cppFunction(depends = "RcppArmadillo", 'arma::cx_mat mExp_C(arma::cx_mat A) {
arma::cx_mat A_exp = arma::expmat(A);
return A_exp;
}')
## write R function
mExp_R <- function(A){
e <- eigen(A)
e$vectors %*% diag(exp(e$values)) %*% solve(e$vectors)
}
## Computation times
A <- matrix(complex(real = rnorm(4), imaginary = rnorm(4)), nrow = 2)
microbenchmark::microbenchmark(mExp_R(A), mExp_C(A))
